name: Precompile PHP

on:
  push:
    branches: [main]
  schedule:
    # Check for updates daily at 2 AM UTC
    - cron: '0 2 * * *'
  workflow_dispatch:
    inputs:
      php_version:
        description: PHP version to build (leave empty for auto-detection)
        required: false
        type: string
      php_config:
        description: PHP build configuration
        required: true
        default: laravel-mysql
        type: choice
        options:
          - laravel-mysql
          - laravel-postgres
          - laravel-sqlite
          - api-only
          - enterprise
          - wordpress
          - full-stack
      force_rebuild:
        description: Force rebuild even if no updates
        required: false
        default: false
        type: boolean

jobs:
  # First job: Check if we need to rebuild based on new PHP versions
  check-for-updates:
    runs-on: ubuntu-latest
    outputs:
      rebuild_needed: ${{ steps.check-updates.outputs.rebuild_needed }}
      reason: ${{ steps.check-updates.outputs.reason }}
      current_versions: ${{ steps.check-updates.outputs.current_versions }}
      latest_versions: ${{ steps.check-updates.outputs.latest_versions }}
      new_versions: ${{ steps.check-updates.outputs.new_versions }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Check for PHP updates
        id: check-updates
        run: |
          # Check if there are new PHP versions available
          UPDATE_CHECK=$(bun scripts/check-php-updates.ts)

          # Extract outputs for GitHub Actions
          REBUILD_NEEDED=$(echo "$UPDATE_CHECK" | grep "rebuild_needed=" | cut -d'=' -f2)
          REASON=$(echo "$UPDATE_CHECK" | grep "reason=" | cut -d'=' -f2-)
          CURRENT_VERSIONS=$(echo "$UPDATE_CHECK" | grep "current_versions=" | cut -d'=' -f2-)
          LATEST_VERSIONS=$(echo "$UPDATE_CHECK" | grep "latest_versions=" | cut -d'=' -f2-)
          NEW_VERSIONS=$(echo "$UPDATE_CHECK" | grep "new_versions=" | cut -d'=' -f2-)

          echo "rebuild_needed=$REBUILD_NEEDED" >> $GITHUB_OUTPUT
          echo "reason=$REASON" >> $GITHUB_OUTPUT
          echo "current_versions=$CURRENT_VERSIONS" >> $GITHUB_OUTPUT
          echo "latest_versions=$LATEST_VERSIONS" >> $GITHUB_OUTPUT
          echo "new_versions=$NEW_VERSIONS" >> $GITHUB_OUTPUT

          echo "$UPDATE_CHECK"

  # Second job: Get dynamic PHP versions from ts-pkgx (only if rebuild is needed)
  get-php-versions:
    needs: check-for-updates
    runs-on: ubuntu-latest
    if: needs.check-for-updates.outputs.rebuild_needed == 'true' || github.event.inputs.force_rebuild == 'true' || github.event.inputs.php_version != ''
    outputs:
      php_versions: ${{ steps.get-versions.outputs.php_versions }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Get PHP versions from ts-pkgx
        id: get-versions
        run: |
          if [ -n "${{ github.event.inputs.php_version }}" ]; then
            # Use specific version if provided
            PHP_VERSIONS='["${{ github.event.inputs.php_version }}"]'
          else
            # Get dynamic PHP versions using our custom script
            PHP_VERSIONS=$(bun scripts/get-php-versions.ts | grep "JSON output for GitHub Actions:" -A 1 | tail -1)
          fi
          echo "php_versions=$PHP_VERSIONS" >> $GITHUB_OUTPUT
          echo "üîç Dynamic PHP versions: $PHP_VERSIONS"

  build:
    needs: [check-for-updates, get-php-versions]
    if: needs.check-for-updates.outputs.rebuild_needed == 'true' || github.event.inputs.force_rebuild == 'true' || github.event.inputs.php_version != ''
    strategy:
      fail-fast: false
      matrix:
        php_version: ${{ fromJson(needs.get-php-versions.outputs.php_versions) }}
        config:
          - laravel-mysql
          - laravel-postgres
          - laravel-sqlite
          - api-only
          - enterprise
          - wordpress
          - full-stack
        os:
          - ubuntu-latest
          - macos-13
          - macos-latest
          - windows-latest
        include:
          - os: ubuntu-latest
            platform: linux
            arch: x86_64
          - os: macos-13
            platform: darwin
            arch: x86_64
          - os: macos-latest
            platform: darwin
            arch: arm64
          - os: windows-latest
            platform: win32
            arch: x86_64

    runs-on: ${{ matrix.os }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Install build dependencies (Linux)
        if: matrix.platform == 'linux'
        run: |
          sudo apt-get update
          sudo apt-get install -y \
            build-essential autoconf automake libtool pkg-config bison re2c \
            libxml2-dev libssl-dev libcurl4-openssl-dev libpng-dev libjpeg-dev \
            libfreetype6-dev libonig-dev libzip-dev libpq-dev libreadline-dev \
            libbz2-dev libgmp-dev libldap2-dev libxslt1-dev libicu-dev \
            libsodium-dev zlib1g-dev libsqlite3-dev libenchant-2-dev \
            libtidy-dev libsnmp-dev libgd-dev libwebp-dev libc-client-dev \
            libkrb5-dev libedit-dev libargon2-dev libffi-dev \
            libmcrypt-dev libmhash-dev libpcre3-dev libexpat1-dev \
            libc-ares-dev libnghttp2-dev libpsl-dev libidn2-dev \
            librtmp-dev libssh2-1-dev libgssapi-krb5-2 libkrb5-dev \
            gettext libgettext-ocaml-dev

      - name: Install build dependencies (macOS)
        if: matrix.platform == 'darwin'
        run: |
          # macOS: Let Launchpad handle all dependencies
          echo "üì¶ macOS build will use Launchpad for all dependencies"
          echo "üöÄ No system package installation needed - Launchpad will provide everything"

      - name: Install build dependencies (Windows)
        if: matrix.platform == 'win32'
        run: |
          # Windows: Install Visual Studio Build Tools and dependencies for PHP compilation
          choco install visualstudio2022buildtools --package-parameters "--add Microsoft.VisualStudio.Workload.VCTools --includeRecommended --includeOptional --passive"
          choco install cmake --installargs 'ADD_CMAKE_TO_PATH=System'
          choco install git
          # Install additional dependencies needed for PHP extensions
          echo "Windows build dependencies installed for PHP compilation"

      - name: Build PHP
        env:
          PHP_VERSION: ${{ matrix.php_version }}
          PHP_CONFIG: ${{ matrix.config }}
          TARGET_PLATFORM: ${{ matrix.platform }}
          TARGET_ARCH: ${{ matrix.arch }}
          BUILD_DIR: ${{ github.workspace }}/build
          OUTPUT_DIR: ${{ github.workspace }}/binaries
        run: bun run scripts/build-php.ts

      - name: Create tarball (Unix)
        if: matrix.platform != 'win32'
        run: |
          cd binaries
          BINARY_NAME="php-${{ matrix.php_version }}-${{ matrix.platform }}-${{ matrix.arch }}-${{ matrix.config }}"
          if [ -d "$BINARY_NAME" ]; then
            # Create metadata file
            echo '{"php_version":"${{ matrix.php_version }}","platform":"${{ matrix.platform }}","arch":"${{ matrix.arch }}","config":"${{ matrix.config }}","built_at":"'$(date -u +%Y-%m-%dT%H:%M:%SZ)'"}' > "$BINARY_NAME/metadata.json"

            # Create tarball
            tar -czf "$BINARY_NAME.tar.gz" "$BINARY_NAME"
            echo "‚úÖ Created tarball: $BINARY_NAME.tar.gz"
            ls -lh "$BINARY_NAME.tar.gz"
          else
            echo "‚ùå Binary directory not found: $BINARY_NAME"
            exit 1
          fi

      - name: Create tarball (Windows)
        if: matrix.platform == 'win32'
        run: |
          cd binaries
          $BINARY_NAME = "php-${{ matrix.php_version }}-${{ matrix.platform }}-${{ matrix.arch }}-${{ matrix.config }}"
          if (Test-Path -Path $BINARY_NAME -PathType Container) {
            # Create metadata file
            $metadata = @{
              php_version = "${{ matrix.php_version }}"
              platform = "${{ matrix.platform }}"
              arch = "${{ matrix.arch }}"
              config = "${{ matrix.config }}"
              built_at = (Get-Date -Format "yyyy-MM-ddTHH:mm:ssZ")
            } | ConvertTo-Json
            $metadata | Out-File -FilePath "$BINARY_NAME\metadata.json" -Encoding UTF8

            # Create zip archive (Windows equivalent of tarball)
            Compress-Archive -Path $BINARY_NAME -DestinationPath "$BINARY_NAME.zip" -Force
            Write-Host "‚úÖ Created archive: $BINARY_NAME.zip"
            Get-ChildItem "$BINARY_NAME.zip" | Format-List Name, Length
          } else {
            Write-Host "‚ùå Binary directory not found: $BINARY_NAME"
            exit 1
          }

      - name: Test PHP Binary (Unix)
        if: matrix.platform != 'win32'
        run: |
          BINARY_NAME="php-${{ matrix.php_version }}-${{ matrix.platform }}-${{ matrix.arch }}-${{ matrix.config }}"
          if [ -f "binaries/$BINARY_NAME/bin/php" ]; then
            echo "‚úÖ PHP binary created successfully"
            binaries/$BINARY_NAME/bin/php --version
            echo "üìã All available extensions:"
            binaries/$BINARY_NAME/bin/php -m

            # Define essential extensions that MUST be present
            REQUIRED_EXTENSIONS=(
              "Core" "date" "hash" "json" "pcre" "Reflection" "SPL" "standard"
              "mbstring" "iconv" "filter" "ctype" "tokenizer" "session" "fileinfo"
              "phar" "dom" "xml" "xmlreader" "xmlwriter" "simplexml"
              "curl" "openssl" "zip" "zlib" "calendar" "ftp" "pcntl" "posix"
              "shmop" "sockets" "exif" "bcmath" "bz2" "gettext" "readline"
            )

            # Define Zend extensions that need special checking
            ZEND_EXTENSIONS=("opcache")

            # Test each required extension
            echo "üß™ Testing essential extensions..."
            MISSING_EXTENSIONS=()
            for ext in "${REQUIRED_EXTENSIONS[@]}"; do
              EXT_LOADED=$(binaries/$BINARY_NAME/bin/php -r "echo extension_loaded('$ext') ? '1' : '0';")
              if [ "$EXT_LOADED" = "1" ]; then
                echo "‚úÖ $ext: LOADED"
              else
                echo "‚ùå $ext: MISSING"
                MISSING_EXTENSIONS+=("$ext")
              fi
            done

            # Test Zend extensions separately
            for ext in "${ZEND_EXTENSIONS[@]}"; do
              EXT_LOADED=$(binaries/$BINARY_NAME/bin/php -r "echo function_exists('opcache_get_status') ? '1' : '0';")
              if [ "$EXT_LOADED" = "1" ]; then
                echo "‚úÖ $ext: LOADED"
              else
                echo "‚ùå $ext: MISSING"
                MISSING_EXTENSIONS+=("$ext")
              fi
            done

            # Check if any essential extensions are missing
            if [ ${#MISSING_EXTENSIONS[@]} -gt 0 ]; then
              echo "‚ùå Critical extensions missing: ${MISSING_EXTENSIONS[*]}"
              echo "This build is incomplete and will cause issues with Composer and Laravel."
              exit 1
            fi

            # Test phar extension functionality specifically
            echo "üß™ Testing phar extension functionality..."
            PHAR_LOADED=$(binaries/$BINARY_NAME/bin/php -r 'echo extension_loaded("phar") ? "1" : "0";')
            if [ "$PHAR_LOADED" = "1" ]; then
              echo "‚úÖ Phar extension is loaded"
              # Test phar creation (essential for Composer)
              echo "üß™ Testing phar creation..."
              echo '<?php
              if (extension_loaded("phar")) {
                try {
                  $phar = new Phar("test.phar");
                  $phar->addFromString("test.txt", "Hello World");
                  echo "‚úÖ Phar creation successful\n";
                  unlink("test.phar");
                } catch (Exception $e) {
                  echo "‚ùå Phar creation failed: " . $e->getMessage() . "\n";
                  exit(1);
                }
              } else {
                echo "‚ùå Phar extension not loaded\n";
                exit(1);
              }
              ?>' > test_phar_create.php
              binaries/$BINARY_NAME/bin/php -d phar.readonly=0 test_phar_create.php
              rm test_phar_create.php
            else
              echo "‚ùå Phar extension not loaded - this will break Composer!"
              exit 1
            fi

            # Test Composer compatibility
            echo "üß™ Testing Composer compatibility..."
            echo '<?php
            // Test essential functions for Composer
            $required_functions = [
                "iconv", "mb_strlen", "filter_var", "hash", "json_encode",
                "curl_init", "openssl_get_cert_locations", "file_get_contents"
            ];

            foreach ($required_functions as $func) {
                if (function_exists($func)) {
                    echo "‚úÖ Function $func: Available\n";
                } else {
                    echo "‚ùå Function $func: Missing\n";
                    exit(1);
                }
            }

            // Test essential classes
            $required_classes = ["Phar", "DOMDocument", "XMLReader", "ZipArchive"];
            foreach ($required_classes as $class) {
                if (class_exists($class)) {
                    echo "‚úÖ Class $class: Available\n";
                } else {
                    echo "‚ùå Class $class: Missing\n";
                    exit(1);
                }
            }

            echo "‚úÖ All Composer compatibility checks passed\n";
            ?>' > test_composer_compat.php
            binaries/$BINARY_NAME/bin/php test_composer_compat.php
            rm test_composer_compat.php

            echo "‚úÖ All PHP binary tests passed successfully!"
          else
            echo "‚ùå PHP binary not found"
            exit 1
          fi

      - name: Test PHP Binary (Windows)
        if: matrix.platform == 'win32'
        run: |
          $BINARY_NAME = "php-${{ matrix.php_version }}-${{ matrix.platform }}-${{ matrix.arch }}-${{ matrix.config }}"
          $phpExeRoot = "binaries\$BINARY_NAME\php.exe"
          $phpExeBin  = "binaries\$BINARY_NAME\bin\php.exe"
          $PHP = if (Test-Path -Path $phpExeRoot -PathType Leaf) { $phpExeRoot } elseif (Test-Path -Path $phpExeBin -PathType Leaf) { $phpExeBin } else { $null }
          Write-Host "Checking for binary at: $PHP"

          # List all files in the binary directory to verify structure
          Write-Host "üìÇ Binary directory structure:"
          Get-ChildItem -Path "binaries\$BINARY_NAME" -Recurse | Format-Table Name, Length, LastWriteTime

          # Check if the PHP binary exists
          if ($PHP -and (Test-Path -Path $PHP -PathType Leaf)) {
            Write-Host "‚úÖ PHP binary exists at expected location"

            # Get file size to verify it's a real binary (not just a placeholder)
            $fileSize = (Get-Item $PHP).Length
            Write-Host "üìä PHP binary size: $fileSize bytes"

            # Test PHP version and extensions
            Write-Host "üß™ Testing PHP binary..."
            & $PHP --version
            Write-Host "üìã All available extensions:"
            & $PHP -m

            # Define essential extensions that MUST be present
            $REQUIRED_EXTENSIONS = @(
              "Core", "date", "hash", "json", "pcre", "Reflection", "SPL", "standard",
              "mbstring", "iconv", "filter", "ctype", "tokenizer", "session", "fileinfo",
              "phar", "dom", "xml", "xmlreader", "xmlwriter", "simplexml",
              "curl", "openssl", "zip", "zlib", "calendar", "ftp",
              "shmop", "sockets", "exif", "bcmath", "bz2", "gettext", "readline"
            )

            # Define Zend extensions that need special checking
            $ZEND_EXTENSIONS = @("opcache")

            # Test each required extension
            Write-Host "üß™ Testing essential extensions..."
            $MISSING_EXTENSIONS = @()
            foreach ($ext in $REQUIRED_EXTENSIONS) {
              $extLoaded = & $PHP -r "echo extension_loaded('$ext') ? '1' : '0';"
              if ($extLoaded -eq "1") {
                Write-Host "‚úÖ $ext`: LOADED"
              } else {
                Write-Host "‚ùå $ext`: MISSING"
                $MISSING_EXTENSIONS += $ext
              }
            }

            # Test Zend extensions separately
            foreach ($ext in $ZEND_EXTENSIONS) {
              $extLoaded = & $PHP -r "echo function_exists('opcache_get_status') ? '1' : '0';"
              if ($extLoaded -eq "1") {
                Write-Host "‚úÖ $ext`: LOADED"
              } else {
                Write-Host "‚ùå $ext`: MISSING"
                $MISSING_EXTENSIONS += $ext
              }
            }

            # Check if any essential extensions are missing
            if ($MISSING_EXTENSIONS.Count -gt 0) {
              Write-Host "‚ùå Critical extensions missing: $($MISSING_EXTENSIONS -join ', ')"
              Write-Host "This build is incomplete and will cause issues with Composer and Laravel."
              exit 1
            }

            # Test phar extension functionality specifically
            Write-Host "üß™ Testing phar extension functionality..."
            $pharLoaded = & $PHP -r 'echo extension_loaded("phar") ? "1" : "0";'
            if ($pharLoaded -eq "1") {
              Write-Host "‚úÖ Phar extension is loaded"
              # Test phar creation (essential for Composer)
              Write-Host "üß™ Testing phar creation..."
              $pharTest = & $PHP -d phar.readonly=0 -r 'try { $p = new Phar("test.phar"); $p->addFromString("t.txt", "x"); echo "OK"; unlink("test.phar"); } catch (Exception $e) { echo "ERR: ".$e->getMessage(); exit(1); }'
              if ($pharTest -eq "OK") {
                Write-Host "‚úÖ Phar creation successful"
              } else {
                Write-Host "‚ùå Phar creation failed: $pharTest"
                exit 1
              }
            } else {
              Write-Host "‚ùå Phar extension not loaded - this will break Composer!"
              exit 1
            }

            # Test Composer compatibility
            Write-Host "üß™ Testing Composer compatibility..."
            $composerTestContent = "<?php`n// Test essential functions for Composer`n`$required_functions = [`n    `"iconv`", `"mb_strlen`", `"filter_var`", `"hash`", `"json_encode`",`n    `"curl_init`", `"openssl_get_cert_locations`", `"file_get_contents`"`n];`n`nforeach (`$required_functions as `$func) {`n    if (function_exists(`$func)) {`n        echo `"‚úÖ Function `$func: Available\n`";`n    } else {`n        echo `"‚ùå Function `$func: Missing\n`";`n        exit(1);`n    }`n}`n`n// Test essential classes`n`$required_classes = [`"Phar`", `"DOMDocument`", `"XMLReader`", `"ZipArchive`"];`nforeach (`$required_classes as `$class) {`n    if (class_exists(`$class)) {`n        echo `"‚úÖ Class `$class: Available\n`";`n    } else {`n        echo `"‚ùå Class `$class: Missing\n`";`n        exit(1);`n    }`n}`n`necho `"‚úÖ All Composer compatibility checks passed\n`";`n?>"
            $composerTestContent | Out-File -FilePath "test_composer_compat.php" -Encoding UTF8
            & $PHP "test_composer_compat.php"
            Remove-Item "test_composer_compat.php"

            # Check if this is likely a real binary based on file size
            if ($fileSize -gt 1000000) {
              Write-Host "‚úÖ PHP binary appears to be a real Windows binary (file size: $fileSize bytes)"

              # Check for DLLs which should be present in a real PHP distribution
              $dllCount = (Get-ChildItem -Path "binaries\$BINARY_NAME" -Filter "*.dll" -Recurse).Count
              Write-Host "Found $dllCount DLL files in the PHP distribution"

              if ($dllCount -gt 10) {
                Write-Host "‚úÖ PHP distribution contains expected DLL files"
              } else {
                Write-Host "‚ö†Ô∏è PHP distribution contains fewer DLL files than expected"
              }
            } else {
              Write-Host "‚ö†Ô∏è PHP binary is smaller than expected, might be a placeholder"
            }

            Write-Host "‚úÖ All PHP binary tests passed successfully!"
          } else {
            Write-Host "‚ùå PHP binary not found at expected location"
            Write-Host "Directory contents:"
            if (Test-Path -Path "binaries\$BINARY_NAME") {
              Get-ChildItem -Path "binaries\$BINARY_NAME" -Recurse
            } else {
              Write-Host "Binary directory does not exist"
            }
            exit 1
          }

      - name: Upload PHP Binary (Unix)
        if: matrix.platform != 'win32'
        uses: actions/upload-artifact@v4.6.2
        with:
          name: php-${{ matrix.php_version }}-${{ matrix.platform }}-${{ matrix.arch }}-${{ matrix.config }}
          path: binaries/php-${{ matrix.php_version }}-${{ matrix.platform }}-${{ matrix.arch }}-${{ matrix.config }}.tar.gz
          retention-days: 30

      - name: Upload PHP Binary (Windows)
        if: matrix.platform == 'win32'
        uses: actions/upload-artifact@v4.6.2
        with:
          name: php-${{ matrix.php_version }}-${{ matrix.platform }}-${{ matrix.arch }}-${{ matrix.config }}
          path: binaries/php-${{ matrix.php_version }}-${{ matrix.platform }}-${{ matrix.arch }}-${{ matrix.config }}.zip
          retention-days: 30

  # Release job to create GitHub releases with binaries
  create-release:
    needs: [check-for-updates, build, get-php-versions]
    runs-on: ubuntu-latest
    if: ((github.event_name == 'push' && github.ref == 'refs/heads/main') || github.event_name == 'workflow_dispatch') && (needs.check-for-updates.outputs.rebuild_needed == 'true' || github.event.inputs.force_rebuild == 'true')

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Bun
        uses: oven-sh/setup-bun@v2
        with:
          bun-version: latest

      - name: Get PHP versions
        id: get-versions
        run: |
          # Get dynamic PHP versions using our custom script
          PHP_VERSIONS=$(bun scripts/get-php-versions.ts | grep "JSON output for GitHub Actions:" -A 1 | tail -1)
          echo "php_versions=$PHP_VERSIONS" >> $GITHUB_OUTPUT
          echo "üîç Dynamic PHP versions: $PHP_VERSIONS"

      - name: Format PHP versions for release
        id: format-versions
        run: |
          # Convert JSON array to comma-separated string
          PHP_VERSIONS_JSON='${{ needs.get-php-versions.outputs.php_versions }}'
          PHP_VERSIONS_STRING=$(echo "$PHP_VERSIONS_JSON" | jq -r 'join(", ")')
          echo "php_versions_string=$PHP_VERSIONS_STRING" >> $GITHUB_OUTPUT

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: binaries/

      - name: Create release manifest
        run: |
          cd binaries/

          # Debug: Show what we have
          echo "üîç Current directory structure:"
          ls -la
          echo ""
          echo "üîç Looking for binary files (tar.gz and zip):"
          find . -name "*.tar.gz" -type f -o -name "*.zip" -type f
          echo ""

          # Create a temporary JSON array file
          echo "[]" > binaries_array.json

          # Process tar.gz files (Unix binaries)
          echo "Processing Unix binaries (.tar.gz files)..."
          for tarball in $(find . -name "*.tar.gz" -type f); do
            filename=$(basename "$tarball")
            size=$(stat -c%s "$tarball" 2>/dev/null || stat -f%z "$tarball")

            echo "Processing: $filename (size: $size bytes)"

            # Extract metadata from tarball if available
            tar -xzOf "$tarball" "*/metadata.json" > temp_metadata.json 2>/dev/null || echo '{}' > temp_metadata.json

            # Parse the binary name to extract components
            # Expected format: php-8.4.11-darwin-arm64-laravel-mysql.tar.gz
            binary_name=$(echo "$filename" | sed 's/\.tar\.gz$//')

            # Extract components from binary name
            if [[ "$binary_name" =~ ^php-([^-]+)-([^-]+)-([^-]+)-(.+)$ ]]; then
              php_version="${BASH_REMATCH[1]}"
              platform="${BASH_REMATCH[2]}"
              architecture="${BASH_REMATCH[3]}"
              configuration="${BASH_REMATCH[4]}"
            else
              # Fallback if pattern doesn't match
              php_version="unknown"
              platform="unknown"
              architecture="unknown"
              configuration="unknown"
            fi

            # Create JSON object for this binary
            binary_json=$(jq -n \
              --arg filename "$filename" \
              --arg size "$size" \
              --arg php_version "$php_version" \
              --arg platform "$platform" \
              --arg architecture "$architecture" \
              --arg configuration "$configuration" \
              --arg built_at "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
              --arg extensions "$(cat temp_metadata.json | jq -r '.extensions // ""' 2>/dev/null || echo '')" \
              '{
                filename: $filename,
                size: ($size | tonumber),
                php_version: $php_version,
                platform: $platform,
                architecture: $architecture,
                configuration: $configuration,
                built_at: $built_at,
                extensions: $extensions
              }')

            # Add this binary to the array using jq
            jq --argjson binary "$binary_json" '. += [$binary]' binaries_array.json > temp_array.json
            mv temp_array.json binaries_array.json
          done

          # Process zip files (Windows binaries)
          echo "Processing Windows binaries (.zip files)..."
          for zipfile in $(find . -name "*.zip" -type f); do
            filename=$(basename "$zipfile")
            size=$(stat -c%s "$zipfile" 2>/dev/null || stat -f%z "$zipfile")

            echo "Processing: $filename (size: $size bytes)"

            # Parse the binary name to extract components
            # Expected format: php-8.4.11-win32-x86_64-laravel-mysql.zip
            binary_name=$(echo "$filename" | sed 's/\.zip$//')

            # Extract components from binary name
            if [[ "$binary_name" =~ ^php-([^-]+)-([^-]+)-([^-]+)-(.+)$ ]]; then
              php_version="${BASH_REMATCH[1]}"
              platform="${BASH_REMATCH[2]}"
              architecture="${BASH_REMATCH[3]}"
              configuration="${BASH_REMATCH[4]}"
            else
              # Fallback if pattern doesn't match
              php_version="unknown"
              platform="unknown"
              architecture="unknown"
              configuration="unknown"
            fi

            # Try to extract metadata from zip if possible
            # This is more complex with zip files, so we'll use a simpler approach
            # Create a temporary directory
            temp_dir="temp_extract_$RANDOM"
            mkdir -p "$temp_dir"

            # Try to extract just the metadata file
            unzip -q -j "$zipfile" "*/metadata.json" -d "$temp_dir" 2>/dev/null || echo '{}' > "$temp_dir/metadata.json"

            # Create JSON object for this binary
            binary_json=$(jq -n \
              --arg filename "$filename" \
              --arg size "$size" \
              --arg php_version "$php_version" \
              --arg platform "$platform" \
              --arg architecture "$architecture" \
              --arg configuration "$configuration" \
              --arg built_at "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
              --arg extensions "$(cat "$temp_dir/metadata.json" | jq -r '.extensions // ""' 2>/dev/null || echo '')" \
              '{
                filename: $filename,
                size: ($size | tonumber),
                php_version: $php_version,
                platform: $platform,
                architecture: $architecture,
                configuration: $configuration,
                built_at: $built_at,
                extensions: $extensions
              }')

            # Add this binary to the array using jq
            jq --argjson binary "$binary_json" '. += [$binary]' binaries_array.json > temp_array.json
            mv temp_array.json binaries_array.json

            # Clean up temp directory
            rm -rf "$temp_dir"
          done

          # Create the final manifest with proper structure and sorted binaries
          jq --arg version "$(date +%Y.%m.%d)" \
             --arg built_at "$(date -u +%Y-%m-%dT%H:%M:%SZ)" \
             --arg commit "${{ github.sha }}" \
             '{
               version: $version,
               built_at: $built_at,
               commit: $commit,
               binaries: (. | sort_by(.php_version))
             }' binaries_array.json > manifest.json

          # Clean up temporary files
          rm -f binaries_array.json temp_metadata.json

          echo ""
          echo "üìã Generated manifest.json:"
          cat manifest.json
          echo ""
          echo "üìä Summary:"
          echo "  - Unix binaries found: $(find . -name "*.tar.gz" -type f | wc -l)"
          echo "  - Windows binaries found: $(find . -name "*.zip" -type f | wc -l)"
          echo "  - Total binaries found: $(find . -name "*.tar.gz" -o -name "*.zip" -type f | wc -l)"
          echo "  - Manifest file size: $(stat -c%s manifest.json 2>/dev/null || stat -f%z manifest.json) bytes"

      - name: Create GitHub Release
        uses: softprops/action-gh-release@v2.3.3
        with:
          tag_name: binaries-${{ github.run_number }}
          name: PHP Binaries - Build ${{ github.run_number }}
          body: |
            üöÄ **PHP Precompiled Binaries**

            > This release contains precompiled PHP binaries optimized for modern PHP usage

            - **Platforms**: Linux (x86_64), macOS (ARM64 & Intel), Windows (x86_64)
            - **PHP Versions**: ${{ steps.format-versions.outputs.php_versions_string }}
            - **Configuration Options**:
              - `laravel-mysql`: Laravel applications using MySQL or MariaDB
              - `laravel-postgres`: Laravel applications using PostgreSQL
              - `laravel-sqlite`: Laravel applications using SQLite
              - `api-only`: Minimal footprint for API-only applications
              - `enterprise`: Full-featured configuration for enterprise applications
              - `wordpress`: WordPress optimized build
              - `full-stack`: Complete PHP build with major extensions and database drivers

            üì¶ **Usage with Launchpad**:
            You may use these however, but if you are looking for automation, these binaries are automatically downloaded by Launchpad instead of compiling from source.

            üîß **Built from commit**: ${{ github.sha }}
            üîÑ **Update Reason**: ${{ needs.check-for-updates.outputs.reason }}

            See `manifest.json` for detailed information about each binary.
          files: |
            binaries/**/*.tar.gz
            binaries/**/*.zip
            binaries/manifest.json
          draft: false
          prerelease: false
