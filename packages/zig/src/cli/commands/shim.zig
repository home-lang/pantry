//! Shim command - Create executable shims for packages
//!
//! Creates lightweight executable scripts that redirect to the actual package binaries.
//! This allows tools to be available in PATH without polluting the global namespace.

const std = @import("std");
const io_helper = @import("../../io_helper.zig");
const lib = @import("../../lib.zig");
const common = @import("common.zig");

const CommandResult = common.CommandResult;

pub const ShimOptions = struct {
    output_dir: ?[]const u8 = null, // Custom output directory for shims
    force: bool = false, // Overwrite existing shims
    verbose: bool = false,
};

/// Create executable shims for specified packages
pub fn shimCommand(allocator: std.mem.Allocator, packages: []const []const u8, options: ShimOptions) !CommandResult {
    if (packages.len == 0) {
        return CommandResult.err(allocator, "Error: No packages specified\nUsage: pantry shim <package>[@version] ...");
    }

    // Determine shim directory
    const shim_dir = if (options.output_dir) |dir|
        try allocator.dupe(u8, dir)
    else blk: {
        const home = try lib.Paths.home(allocator);
        defer allocator.free(home);
        break :blk try std.fmt.allocPrint(allocator, "{s}/.local/bin", .{home});
    };
    defer allocator.free(shim_dir);

    // Ensure shim directory exists
    try io_helper.makePath(shim_dir);

    if (options.verbose) {
        std.debug.print("Creating shims in: {s}\n\n", .{shim_dir});
    }

    var created: usize = 0;
    var skipped: usize = 0;
    var failed: usize = 0;

    for (packages) |pkg_str| {
        // Parse package string (format: "name" or "name@version")
        var name = pkg_str;
        var version: []const u8 = "latest";

        if (std.mem.indexOf(u8, pkg_str, "@")) |at_pos| {
            name = pkg_str[0..at_pos];
            version = pkg_str[at_pos + 1 ..];
        }

        // Create shim for this package
        const result = createShim(allocator, shim_dir, name, version, options);
        if (result) |shim_path| {
            std.debug.print("✓ Created shim: {s}\n", .{shim_path});
            allocator.free(shim_path);
            created += 1;
        } else |err| {
            switch (err) {
                error.ShimExists => {
                    if (options.verbose) {
                        std.debug.print("⚠ Skipped {s} (already exists, use --force to overwrite)\n", .{name});
                    }
                    skipped += 1;
                },
                else => {
                    std.debug.print("✗ Failed to create shim for {s}: {}\n", .{ name, err });
                    failed += 1;
                },
            }
        }
    }

    std.debug.print("\n", .{});

    if (failed > 0) {
        const msg = try std.fmt.allocPrint(
            allocator,
            "Shim creation completed with errors: {d} created, {d} skipped, {d} failed",
            .{ created, skipped, failed },
        );
        return .{ .exit_code = 1, .message = msg };
    }

    const msg = try std.fmt.allocPrint(
        allocator,
        "✅ Created {d} shim(s) in {s}\n\nMake sure {s} is in your PATH:\n  export PATH=\"{s}:$PATH\"",
        .{ created, shim_dir, shim_dir, shim_dir },
    );
    return .{ .exit_code = 0, .message = msg };
}

/// Create a single shim for a package
fn createShim(
    allocator: std.mem.Allocator,
    shim_dir: []const u8,
    name: []const u8,
    version: []const u8,
    options: ShimOptions,
) ![]const u8 {
    const shim_path = try std.fs.path.join(allocator, &[_][]const u8{ shim_dir, name });
    errdefer allocator.free(shim_path);

    // Check if shim already exists
    if (!options.force) {
        io_helper.cwd().access(io_helper.io, shim_path, .{}) catch |err| {
            if (err != error.FileNotFound) {
                return err;
            }
            // File doesn't exist, continue
        };

        // If we get here without error, file exists
        if (io_helper.cwd().access(io_helper.io, shim_path, .{})) |_| {
            return error.ShimExists;
        } else |_| {}
    }

    // Generate shim content
    const shim_content = try generateShimScript(allocator, name, version);
    defer allocator.free(shim_content);

    // Write shim file using io_helper API
    const fs_file = try io_helper.cwd().createFile(io_helper.io, shim_path, .{});
    defer fs_file.close(io_helper.io);

    try io_helper.writeAllToFile(fs_file, shim_content);

    // Make executable (chmod +x)
    _ = std.c.fchmod(fs_file.handle, 0o755);

    return shim_path;
}

/// Generate the shim script content
fn generateShimScript(allocator: std.mem.Allocator, name: []const u8, version: []const u8) ![]const u8 {
    // Create a shell script that uses pantry to run the package
    return std.fmt.allocPrint(allocator,
        \\#!/bin/sh
        \\# Shim for {s}@{s}
        \\# Generated by pantry
        \\
        \\exec pantry px {s}@{s} "$@"
        \\
    , .{ name, version, name, version });
}

/// List existing shims
pub fn shimListCommand(allocator: std.mem.Allocator) !CommandResult {
    const home = try lib.Paths.home(allocator);
    defer allocator.free(home);

    const shim_dir = try std.fmt.allocPrint(allocator, "{s}/.local/bin", .{home});
    defer allocator.free(shim_dir);

    var dir = io_helper.openDir(shim_dir, .{ .iterate = true }) catch |err| {
        if (err == error.FileNotFound) {
            return CommandResult.err(allocator, "No shims directory found. Run 'pantry shim <package>' to create shims.");
        }
        return err;
    };
    defer dir.close(io_helper.io);

    std.debug.print("Shims in {s}:\n\n", .{shim_dir});

    var count: usize = 0;
    var iter = dir.iterate();
    while (try iter.next(io_helper.io)) |entry| {
        if (entry.kind == .file) {
            // Check if it's a pantry shim by reading the first line
            const file_path = try std.fs.path.join(allocator, &[_][]const u8{ shim_dir, entry.name });
            defer allocator.free(file_path);

            const content = io_helper.readFileAlloc(allocator, file_path, 1024) catch continue;
            defer allocator.free(content);

            if (std.mem.indexOf(u8, content, "# Generated by pantry") != null) {
                std.debug.print("  {s}\n", .{entry.name});
                count += 1;
            }
        }
    }

    if (count == 0) {
        std.debug.print("  (no pantry shims found)\n", .{});
    }

    std.debug.print("\nTotal: {d} shim(s)\n", .{count});

    return .{ .exit_code = 0 };
}

/// Remove a shim
pub fn shimRemoveCommand(allocator: std.mem.Allocator, names: []const []const u8) !CommandResult {
    if (names.len == 0) {
        return CommandResult.err(allocator, "Error: No shim names specified\nUsage: pantry shim:remove <name> ...");
    }

    const home = try lib.Paths.home(allocator);
    defer allocator.free(home);

    const shim_dir = try std.fmt.allocPrint(allocator, "{s}/.local/bin", .{home});
    defer allocator.free(shim_dir);

    var removed: usize = 0;
    var not_found: usize = 0;

    for (names) |name| {
        const shim_path = try std.fs.path.join(allocator, &[_][]const u8{ shim_dir, name });
        defer allocator.free(shim_path);

        io_helper.deleteFile(shim_path) catch |err| {
            if (err == error.FileNotFound) {
                std.debug.print("⚠ Shim not found: {s}\n", .{name});
                not_found += 1;
                continue;
            }
            return err;
        };

        std.debug.print("✓ Removed shim: {s}\n", .{name});
        removed += 1;
    }

    const msg = try std.fmt.allocPrint(allocator, "Removed {d} shim(s)", .{removed});
    return .{ .exit_code = if (not_found > 0) 1 else 0, .message = msg };
}
