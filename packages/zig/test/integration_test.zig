const std = @import("std");
const lib = @import("lib");
const testing = std.testing;

// Integration tests comparing Zig implementation with TypeScript behavior
// These tests ensure compatibility between the Zig and TypeScript versions

// Test cache format compatibility
// The Zig implementation should produce cache files compatible with TypeScript version
test "Cache format compatibility with TypeScript" {
    const allocator = testing.allocator;

    // Create a cache entry similar to what TypeScript produces
    const expected_format =
        \\{
        \\  "version": "1.0.0",
        \\  "hash": "abc123def456",
        \\  "timestamp": 1234567890,
        \\  "packages": {
        \\    "node": {
        \\      "version": "22.0.0",
        \\      "path": "/usr/local/share/launchpad/global/nodejs.org/v22.0.0"
        \\    }
        \\  }
        \\}
    ;

    // TODO: Parse cache format and verify structure
    _ = allocator;
    _ = expected_format;

    // Verify that Zig can read TypeScript-generated cache files
    // Verify that TypeScript can read Zig-generated cache files
}

// Test shell integration output compatibility
// Shell code generated by Zig should be identical to TypeScript version
test "Shell integration output matches TypeScript" {
    const allocator = testing.allocator;

    // Expected shell code format from TypeScript
    const expected_shell_code =
        \\# Launchpad environment activation
        \\export PATH="/usr/local/share/launchpad/global/bin:$PATH"
        \\export LAUNCHPAD_ENV="test-env"
    ;

    _ = allocator;
    _ = expected_shell_code;

    // TODO: Generate shell code with Zig implementation
    // TODO: Compare with TypeScript-generated output
    // TODO: Verify both produce identical shell code
}

// Test environment hash generation
// MD5 hash of environment should match between implementations
test "Environment hash matches TypeScript implementation" {
    const allocator = testing.allocator;

    // Test case: same environment variables should produce same hash
    const env_vars = [_][]const u8{
        "NODE_VERSION=22.0.0",
        "BUN_VERSION=1.2.0",
        "PYTHON_VERSION=3.12.0",
    };

    const zig_hash = try lib.string.hashEnvironment(&env_vars, allocator);

    // Expected hash from TypeScript (MD5 of sorted env vars)
    // This is a known hash for the test environment
    const expected_hash_hex = "e3b0c44298fc1c149afbf4c8996fb924"; // Placeholder

    const zig_hash_hex = try lib.string.hashToHex(zig_hash, allocator);
    defer allocator.free(zig_hash_hex);

    _ = expected_hash_hex;
    // TODO: Verify hash matches TypeScript implementation
    // TODO: Test with actual environment from TypeScript
}

// Test package resolution compatibility
// Package lookups should produce identical results
test "Package resolution matches TypeScript" {
    // Test that package name resolution works identically
    // e.g., "node@22" should resolve to same version in both implementations

    const test_packages = [_]struct {
        input: []const u8,
        expected_name: []const u8,
        expected_version: []const u8,
    }{
        .{ .input = "node@22", .expected_name = "node", .expected_version = "22.0.0" },
        .{ .input = "bun@1.2", .expected_name = "bun", .expected_version = "1.2.0" },
        .{ .input = "python", .expected_name = "python", .expected_version = "3.12.0" },
    };

    _ = test_packages;
    // TODO: Implement package resolution in Zig
    // TODO: Compare with TypeScript package resolution
}

// Test path resolution compatibility
// Platform-specific paths should match TypeScript version
test "Path resolution matches TypeScript" {
    const allocator = testing.allocator;

    // Test cache path
    const cache_path = try lib.Paths.cache(allocator);
    defer allocator.free(cache_path);

    // Verify path structure matches TypeScript:
    // macOS: ~/Library/Caches/launchpad
    // Linux: ~/.cache/launchpad
    // Windows: %LOCALAPPDATA%\launchpad\cache

    try testing.expect(std.mem.indexOf(u8, cache_path, "launchpad") != null);

    // TODO: Test against actual TypeScript-generated paths
    // TODO: Verify XDG_CACHE_HOME handling on Linux
    // TODO: Verify environment variable precedence
}

// Test symlink structure compatibility
// Symlink layout should match TypeScript version
test "Symlink structure matches TypeScript" {
    // Verify that installed packages use same symlink structure
    // e.g., /usr/local/share/launchpad/global/bin/node -> ../nodejs.org/v22.0.0/bin/node

    // TODO: Test symlink creation
    // TODO: Verify symlink resolution
    // TODO: Compare with TypeScript symlink structure
}

// Test error message compatibility
// Error messages should be consistent between implementations
test "Error messages match TypeScript format" {
    const allocator = testing.allocator;

    const test_error = error.PackageNotFound;
    const formatted = try lib.errors.formatError(test_error, allocator);
    defer allocator.free(formatted);

    // Error messages should be user-friendly and consistent
    try testing.expect(formatted.len > 0);

    // TODO: Compare with TypeScript error messages
    // TODO: Verify error codes match
    // TODO: Test all error types
}

// Test configuration file parsing compatibility
// Should handle same config format as TypeScript
test "Config file parsing matches TypeScript" {
    // Test parsing of launchpad.config.ts/yaml
    // Should support same configuration options

    const sample_config =
        \\dependencies:
        \\  node: 22
        \\  bun: 1.2
        \\  python: 3.12
        \\services:
        \\  postgres:
        \\    version: 16
        \\    port: 5432
    ;

    _ = sample_config;
    // TODO: Parse config with Zig
    // TODO: Compare with TypeScript config parser
    // TODO: Verify all config options supported
}

// Performance baseline: Cache lookup speed
test "Performance: Cache lookup" {
    const allocator = testing.allocator;

    // Warm up
    const hash = lib.string.md5Hash("test-project");
    const hex = try lib.string.hashToHex(hash, allocator);
    defer allocator.free(hex);

    // Benchmark cache lookup
    const iterations = 10000;
    const start = std.time.nanoTimestamp();

    var i: usize = 0;
    while (i < iterations) : (i += 1) {
        const h = lib.string.md5Hash("test-project");
        _ = h;
    }

    const end = std.time.nanoTimestamp();
    const duration_ns = @as(u64, @intCast(end - start));
    const avg_ns = duration_ns / iterations;

    std.debug.print("\nCache lookup avg: {}ns ({} lookups/sec)\n", .{
        avg_ns,
        1_000_000_000 / avg_ns,
    });

    // Target: < 100ns per lookup
    try testing.expect(avg_ns < 1000); // Allow 1μs for now, optimize to < 100ns
}

// Performance baseline: Shell code generation speed
test "Performance: Shell code generation" {
    const iterations = 1000;
    const start = std.time.nanoTimestamp();

    var i: usize = 0;
    while (i < iterations) : (i += 1) {
        // TODO: Generate shell code
        // For now, just measure hash generation as proxy
        const hash = lib.string.md5Hash("/test/path");
        _ = hash;
    }

    const end = std.time.nanoTimestamp();
    const duration_ns = @as(u64, @intCast(end - start));
    const avg_ns = duration_ns / iterations;

    std.debug.print("\nShell code generation avg: {}ns\n", .{avg_ns});

    // Target: < 1ms per generation
    try testing.expect(avg_ns < 1_000_000); // 1ms
}

// Performance baseline: MD5 hashing speed
test "Performance: MD5 hashing" {
    const allocator = testing.allocator;
    const iterations = 100000;

    const test_string = "/Users/test/project/package.json";

    const start = std.time.nanoTimestamp();

    var i: usize = 0;
    while (i < iterations) : (i += 1) {
        const hash = lib.string.md5Hash(test_string);
        _ = hash;
    }

    const end = std.time.nanoTimestamp();
    const duration_ns = @as(u64, @intCast(end - start));
    const avg_ns = duration_ns / iterations;

    std.debug.print("\nMD5 hash avg: {}ns\n", .{avg_ns});

    // Target: < 200μs per hash (improvement from ~20ms in TypeScript)
    try testing.expect(avg_ns < 200_000); // 200μs
}

// Performance comparison: String interning vs allocation
test "Performance: String interning benefits" {
    const allocator = testing.allocator;
    var interner = lib.string.StringInterner.init(allocator);
    defer interner.deinit();

    const test_strings = [_][]const u8{
        "/Users/test/project1",
        "/Users/test/project2",
        "/Users/test/project1", // Duplicate
        "/Users/test/project3",
        "/Users/test/project1", // Duplicate
    };

    // Test interning performance
    const iterations = 10000;
    const start = std.time.nanoTimestamp();

    var i: usize = 0;
    while (i < iterations) : (i += 1) {
        for (test_strings) |s| {
            _ = try interner.intern(s);
        }
    }

    const end = std.time.nanoTimestamp();
    const duration_ns = @as(u64, @intCast(end - start));
    const avg_ns = duration_ns / (iterations * test_strings.len);

    std.debug.print("\nString interning avg: {}ns per operation\n", .{avg_ns});

    // Should be very fast after first intern
    try testing.expect(avg_ns < 100); // < 100ns per lookup
}

// Integration test: Full environment activation flow
test "Integration: Environment activation workflow" {
    const allocator = testing.allocator;

    // Simulate full workflow:
    // 1. Detect project directory
    // 2. Hash dependency file
    // 3. Check cache
    // 4. Generate shell code
    // 5. Activate environment

    const project_dir = "/Users/test/project";
    const dep_file = "package.json";

    // Step 1-2: Hash dependency file path
    var path_buf: [std.fs.max_path_bytes]u8 = undefined;
    const full_path = try std.fmt.bufPrint(&path_buf, "{s}/{s}", .{ project_dir, dep_file });
    const hash = lib.string.hashDependencyFile(full_path);
    const hash_hex = try lib.string.hashToHex(hash, allocator);
    defer allocator.free(hash_hex);

    try testing.expect(hash_hex.len == 32);

    // TODO: Step 3: Check cache
    // TODO: Step 4: Generate shell code
    // TODO: Step 5: Verify activation
}

// Cross-platform compatibility test
test "Cross-platform: Path handling" {
    const allocator = testing.allocator;

    // Test that path handling works correctly on current platform
    const home = try lib.Paths.home(allocator);
    defer allocator.free(home);

    const cache = try lib.Paths.cache(allocator);
    defer allocator.free(cache);

    const data = try lib.Paths.data(allocator);
    defer allocator.free(data);

    // All paths should be absolute and platform-appropriate
    try testing.expect(std.fs.path.isAbsolute(home));
    try testing.expect(std.fs.path.isAbsolute(cache));
    try testing.expect(std.fs.path.isAbsolute(data));

    // Paths should use platform-specific separators
    switch (lib.Platform.current()) {
        .darwin, .linux => {
            try testing.expect(std.mem.indexOf(u8, cache, "/") != null);
            try testing.expect(std.mem.indexOf(u8, cache, "\\") == null);
        },
        .windows => {
            try testing.expect(std.mem.indexOf(u8, cache, "\\") != null);
        },
    }
}
