const std = @import("std");
const lib = @import("lib");
const testing = std.testing;

// Integration tests comparing Zig implementation with TypeScript behavior
// These tests ensure compatibility between the Zig and TypeScript versions

// Test cache format compatibility
// The Zig implementation should produce cache files compatible with TypeScript version
test "Cache format compatibility with TypeScript" {
    const allocator = testing.allocator;

    // Create a cache entry similar to what TypeScript produces
    const expected_format =
        \\{
        \\  "version": "1.0.0",
        \\  "hash": "abc123def456",
        \\  "timestamp": 1234567890,
        \\  "packages": {
        \\    "node": {
        \\      "version": "22.0.0",
        \\      "path": "/usr/local/share/pantry/global/nodejs.org/v22.0.0"
        \\    }
        \\  }
        \\}
    ;

    // Verify we can parse the expected JSON format
    const parsed = try std.json.parseFromSlice(
        std.json.Value,
        allocator,
        expected_format,
        .{},
    );
    defer parsed.deinit();

    const root = parsed.value.object;

    // Verify cache structure
    try testing.expect(root.contains("version"));
    try testing.expect(root.contains("hash"));
    try testing.expect(root.contains("timestamp"));
    try testing.expect(root.contains("packages"));

    // Verify packages structure
    const packages = root.get("packages").?.object;
    try testing.expect(packages.contains("node"));

    const node = packages.get("node").?.object;
    try testing.expect(node.contains("version"));
    try testing.expect(node.contains("path"));

    // Future: Test bidirectional compatibility with TypeScript
}

// Test shell integration output compatibility
// Shell code generated by Zig should be identical to TypeScript version
test "Shell integration output matches TypeScript" {
    const allocator = testing.allocator;

    // Expected shell code format from TypeScript
    const expected_shell_code =
        \\# pantry environment activation
        \\export PATH="/usr/local/share/pantry/global/bin:$PATH"
        \\export pantry_ENV="test-env"
    ;

    // Test shell code format validation
    // Verify expected shell code has required components
    try testing.expect(std.mem.indexOf(u8, expected_shell_code, "export PATH=") != null);
    try testing.expect(std.mem.indexOf(u8, expected_shell_code, "pantry") != null);

    // Test shell code generation (basic validation)
    const test_path = "/usr/local/share/pantry/global/bin";
    const shell_export = try std.fmt.allocPrint(
        allocator,
        "export PATH=\"{s}:$PATH\"",
        .{test_path},
    );
    defer allocator.free(shell_export);

    try testing.expect(std.mem.indexOf(u8, shell_export, test_path) != null);
    try testing.expect(std.mem.indexOf(u8, shell_export, "export PATH=") != null);

    // Future: Generate full shell code and compare with TypeScript output
}

// Test environment hash generation
// MD5 hash of environment should match between implementations
test "Environment hash matches TypeScript implementation" {
    const allocator = testing.allocator;

    // Test case: same environment variables should produce same hash
    const env_vars = [_][]const u8{
        "NODE_VERSION=22.0.0",
        "BUN_VERSION=1.2.0",
        "PYTHON_VERSION=3.12.0",
    };

    const zig_hash = try lib.string.hashEnvironment(&env_vars, allocator);

    // Expected hash from TypeScript (MD5 of sorted env vars)
    // This is a known hash for the test environment
    const expected_hash_hex = "e3b0c44298fc1c149afbf4c8996fb924"; // Placeholder

    const zig_hash_hex = try lib.string.hashToHex(zig_hash, allocator);
    defer allocator.free(zig_hash_hex);

    // Verify hash is 32 characters (MD5 hex)
    try testing.expectEqual(@as(usize, 32), zig_hash_hex.len);

    // Verify hash is consistent (same input = same output)
    const zig_hash2 = try lib.string.hashEnvironment(&env_vars, allocator);
    const zig_hash_hex2 = try lib.string.hashToHex(zig_hash2, allocator);
    defer allocator.free(zig_hash_hex2);

    try testing.expectEqualStrings(zig_hash_hex, zig_hash_hex2);

    _ = expected_hash_hex; // Future: verify against known TypeScript hash
}

// Test package resolution compatibility
// Package lookups should produce identical results
test "Package resolution matches TypeScript" {
    // Test that package name resolution works identically
    // e.g., "node@22" should resolve to same version in both implementations

    const test_packages = [_]struct {
        input: []const u8,
        expected_name: []const u8,
        expected_version: []const u8,
    }{
        .{ .input = "node@22", .expected_name = "node", .expected_version = "22.0.0" },
        .{ .input = "bun@1.2", .expected_name = "bun", .expected_version = "1.2.0" },
        .{ .input = "python", .expected_name = "python", .expected_version = "3.12.0" },
    };

    // Note: Package resolution is implemented in the resolver module
    // This test validates the expected input/output format
    for (test_packages) |pkg| {
        // Verify test data structure is valid
        try testing.expect(pkg.input.len > 0);
        try testing.expect(pkg.expected_name.len > 0);
        try testing.expect(pkg.expected_version.len > 0);

        // Verify format: name@version
        const has_at = std.mem.indexOf(u8, pkg.input, "@");
        if (has_at == null) {
            // No version specified - bare package name
            try testing.expectEqualStrings(pkg.expected_name, pkg.input);
        }
    }

    // Future: Integrate with actual package resolver once implemented
}

// Test path resolution compatibility
// Platform-specific paths should match TypeScript version
test "Path resolution matches TypeScript" {
    const allocator = testing.allocator;

    // Test cache path
    const cache_path = try lib.Paths.cache(allocator);
    defer allocator.free(cache_path);

    // Verify path structure matches TypeScript:
    // macOS: ~/Library/Caches/pantry
    // Linux: ~/.cache/pantry
    // Windows: %LOCALAPPDATA%\pantry\cache

    try testing.expect(std.mem.indexOf(u8, cache_path, "pantry") != null);

    // Verify path is absolute
    try testing.expect(std.fs.path.isAbsolute(cache_path));

    // Verify platform-specific structure
    switch (lib.Platform.current()) {
        .darwin => {
            // macOS: should contain "Library/Caches"
            try testing.expect(std.mem.indexOf(u8, cache_path, "Library/Caches") != null or
                std.mem.indexOf(u8, cache_path, ".cache") != null);
        },
        .linux => {
            // Linux: should contain ".cache" (XDG_CACHE_HOME or ~/.cache)
            try testing.expect(std.mem.indexOf(u8, cache_path, ".cache") != null);
        },
        .windows => {
            // Windows: should contain "cache"
            try testing.expect(std.mem.indexOf(u8, cache_path, "cache") != null);
        },
    }
}

// Test symlink structure compatibility
// Symlink layout should match TypeScript version
test "Symlink structure matches TypeScript" {
    // Verify that installed packages use same symlink structure
    // e.g., /usr/local/share/pantry/global/bin/node -> ../nodejs.org/v22.0.0/bin/node

    const allocator = testing.allocator;

    // Test expected symlink path format
    const expected_target = "../nodejs.org/v22.0.0/bin/node";
    const expected_link = "/usr/local/share/pantry/global/bin/node";

    // Verify path structure is correct
    try testing.expect(std.mem.indexOf(u8, expected_target, "../") != null);
    try testing.expect(std.mem.indexOf(u8, expected_target, "nodejs.org") != null);
    try testing.expect(std.mem.indexOf(u8, expected_link, "pantry/global/bin") != null);

    // Test path manipulation functions
    const dirname = std.fs.path.dirname(expected_link) orelse "";
    try testing.expect(std.mem.endsWith(u8, dirname, "bin"));

    const basename = std.fs.path.basename(expected_link);
    try testing.expectEqualStrings("node", basename);

    _ = allocator;
    // Future: Test actual symlink creation and resolution
}

// Test error message compatibility
// Error messages should be consistent between implementations
test "Error messages match TypeScript format" {
    const allocator = testing.allocator;

    const test_error = error.PackageNotFound;
    const formatted = try lib.errors.formatError(test_error, allocator);
    defer allocator.free(formatted);

    // Error messages should be user-friendly and consistent
    try testing.expect(formatted.len > 0);

    // Verify error message is descriptive
    try testing.expect(std.mem.indexOf(u8, formatted, "not found") != null or
        std.mem.indexOf(u8, formatted, "Package") != null);

    // Test error consistency - same error should produce same message
    const formatted2 = try lib.errors.formatError(test_error, allocator);
    defer allocator.free(formatted2);

    try testing.expectEqualStrings(formatted, formatted2);

    // Future: Compare with TypeScript error messages and verify error codes
}

// Test configuration file parsing compatibility
// Should handle same config format as TypeScript
test "Config file parsing matches TypeScript" {
    // Test parsing of pantry.config.ts/yaml
    // Should support same configuration options

    const sample_config =
        \\dependencies:
        \\  node: 22
        \\  bun: 1.2
        \\  python: 3.12
        \\services:
        \\  postgres:
        \\    version: 16
        \\    port: 5432
    ;

    // For now, verify YAML format is valid
    // Future implementation would parse YAML config files
    try testing.expect(std.mem.indexOf(u8, sample_config, "dependencies:") != null);
    try testing.expect(std.mem.indexOf(u8, sample_config, "services:") != null);

    // Test that we can at least detect config format
    const has_dependencies = std.mem.indexOf(u8, sample_config, "dependencies:") != null;
    const has_services = std.mem.indexOf(u8, sample_config, "services:") != null;

    try testing.expect(has_dependencies);
    try testing.expect(has_services);

    // Future: Full YAML parser integration and TypeScript compatibility
}

// Performance baseline: Cache lookup speed
test "Performance: Cache lookup" {
    const allocator = testing.allocator;

    // Warm up
    const hash = lib.string.md5Hash("test-project");
    const hex = try lib.string.hashToHex(hash, allocator);
    defer allocator.free(hex);

    // Benchmark cache lookup
    const iterations = 10000;
    const start = std.time.nanoTimestamp();

    var i: usize = 0;
    while (i < iterations) : (i += 1) {
        const h = lib.string.md5Hash("test-project");
        _ = h;
    }

    const end = std.time.nanoTimestamp();
    const duration_ns = @as(u64, @intCast(end - start));
    const avg_ns = duration_ns / iterations;

    std.debug.print("\nCache lookup avg: {}ns ({} lookups/sec)\n", .{
        avg_ns,
        1_000_000_000 / avg_ns,
    });

    // Target: < 100ns per lookup
    try testing.expect(avg_ns < 1000); // Allow 1μs for now, optimize to < 100ns
}

// Performance baseline: Shell code generation speed
test "Performance: Shell code generation" {
    const iterations = 1000;
    const start = std.time.nanoTimestamp();

    const allocator = testing.allocator;

    var i: usize = 0;
    while (i < iterations) : (i += 1) {
        // Measure path formatting (simulates shell code generation)
        const test_bin_path = "/usr/local/share/pantry/global/bin";
        const shell_code = try std.fmt.allocPrint(
            allocator,
            "export PATH=\"{s}:$PATH\"",
            .{test_bin_path},
        );
        allocator.free(shell_code);
    }

    const end = std.time.nanoTimestamp();
    const duration_ns = @as(u64, @intCast(end - start));
    const avg_ns = duration_ns / iterations;

    std.debug.print("\nShell code generation avg: {}ns\n", .{avg_ns});

    // Target: < 1ms per generation
    try testing.expect(avg_ns < 1_000_000); // 1ms
}

// Performance baseline: MD5 hashing speed
test "Performance: MD5 hashing" {
    _ = testing.allocator; // For future use
    const iterations = 100000;

    const test_string = "/Users/test/project/package.json";

    const start = std.time.nanoTimestamp();

    var i: usize = 0;
    while (i < iterations) : (i += 1) {
        const hash = lib.string.md5Hash(test_string);
        _ = hash;
    }

    const end = std.time.nanoTimestamp();
    const duration_ns = @as(u64, @intCast(end - start));
    const avg_ns = duration_ns / iterations;

    std.debug.print("\nMD5 hash avg: {}ns\n", .{avg_ns});

    // Target: < 200μs per hash (improvement from ~20ms in TypeScript)
    try testing.expect(avg_ns < 200_000); // 200μs
}

// Performance comparison: String interning vs allocation
test "Performance: String interning benefits" {
    const allocator = testing.allocator;
    var interner = lib.string.StringInterner.init(allocator);
    defer interner.deinit();

    const test_strings = [_][]const u8{
        "/Users/test/project1",
        "/Users/test/project2",
        "/Users/test/project1", // Duplicate
        "/Users/test/project3",
        "/Users/test/project1", // Duplicate
    };

    // Test interning performance
    const iterations = 10000;
    const start = std.time.nanoTimestamp();

    var i: usize = 0;
    while (i < iterations) : (i += 1) {
        for (test_strings) |s| {
            _ = try interner.intern(s);
        }
    }

    const end = std.time.nanoTimestamp();
    const duration_ns = @as(u64, @intCast(end - start));
    const avg_ns = duration_ns / (iterations * test_strings.len);

    std.debug.print("\nString interning avg: {}ns per operation\n", .{avg_ns});

    // Should be very fast after first intern
    // Adjusted threshold for CI environments which can be much slower
    try testing.expect(avg_ns < 2000); // < 2000ns (2µs) per lookup - very lenient for CI
}

// Integration test: Full environment activation flow
test "Integration: Environment activation workflow" {
    const allocator = testing.allocator;

    // Simulate full workflow:
    // 1. Detect project directory
    // 2. Hash dependency file
    // 3. Check cache
    // 4. Generate shell code
    // 5. Activate environment

    const project_dir = "/Users/test/project";
    const dep_file = "package.json";

    // Step 1-2: Hash dependency file path
    var path_buf: [std.fs.max_path_bytes]u8 = undefined;
    const full_path = try std.fmt.bufPrint(&path_buf, "{s}/{s}", .{ project_dir, dep_file });
    const hash = lib.string.hashDependencyFile(full_path);
    const hash_hex = try lib.string.hashToHex(hash, allocator);
    defer allocator.free(hash_hex);

    try testing.expect(hash_hex.len == 32);

    // Step 3: Verify hash is deterministic
    const hash2 = lib.string.hashDependencyFile(full_path);
    const hash_hex2 = try lib.string.hashToHex(hash2, allocator);
    defer allocator.free(hash_hex2);

    try testing.expectEqualStrings(hash_hex, hash_hex2);

    // Step 4: Verify hash format (32 hex characters)
    for (hash_hex) |c| {
        try testing.expect((c >= '0' and c <= '9') or (c >= 'a' and c <= 'f'));
    }

    // Future: Implement cache checking and shell code generation
}

// Cross-platform compatibility test
test "Cross-platform: Path handling" {
    const allocator = testing.allocator;

    // Test that path handling works correctly on current platform
    const home = try lib.Paths.home(allocator);
    defer allocator.free(home);

    const cache = try lib.Paths.cache(allocator);
    defer allocator.free(cache);

    const data = try lib.Paths.data(allocator);
    defer allocator.free(data);

    // All paths should be absolute and platform-appropriate
    try testing.expect(std.fs.path.isAbsolute(home));
    try testing.expect(std.fs.path.isAbsolute(cache));
    try testing.expect(std.fs.path.isAbsolute(data));

    // Paths should use platform-specific separators
    switch (lib.Platform.current()) {
        .darwin, .linux => {
            try testing.expect(std.mem.indexOf(u8, cache, "/") != null);
            try testing.expect(std.mem.indexOf(u8, cache, "\\") == null);
        },
        .windows => {
            try testing.expect(std.mem.indexOf(u8, cache, "\\") != null);
        },
    }
}
