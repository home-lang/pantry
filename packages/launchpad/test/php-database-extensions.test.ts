import { afterEach, beforeEach, describe, expect, it } from 'bun:test'
import fs from 'node:fs'
import os from 'node:os'
import path from 'node:path'
import process from 'node:process'
import { config } from '../src/config'

describe('PHP Database Extensions', () => {
  let originalEnv: NodeJS.ProcessEnv
  let tempDir: string
  let mockInstallPath: string
  let originalConfig: typeof config

  beforeEach(() => {
    originalEnv = { ...process.env }
    originalConfig = { ...config }
    tempDir = fs.mkdtempSync(path.join(os.tmpdir(), 'launchpad-php-ext-test-'))
    mockInstallPath = path.join(tempDir, 'install')

    // Set test environment
    process.env.NODE_ENV = 'test'
    process.env.LAUNCHPAD_TEST_MODE = 'true'

    // Override config for testing
    config.verbose = false

    // Create mock installation structure
    fs.mkdirSync(path.join(mockInstallPath, 'bin'), { recursive: true })
    fs.mkdirSync(path.join(mockInstallPath, 'lib', 'php', '20240924'), { recursive: true })
    fs.mkdirSync(path.join(mockInstallPath, 'etc'), { recursive: true })
  })

  afterEach(() => {
    // Restore environment variables properly without replacing the entire process.env object
    Object.keys(process.env).forEach((key) => {
      delete process.env[key]
    })
    Object.assign(process.env, originalEnv)
    Object.assign(config, originalConfig)

    if (fs.existsSync(tempDir)) {
      fs.rmSync(tempDir, { recursive: true, force: true })
    }
  })

  describe('PHP Database Extension Detection', () => {
    it('should detect missing PostgreSQL extension', async () => {
      // Create mock PHP binary without extensions
      const phpBinary = path.join(mockInstallPath, 'bin', 'php')
      const mockPhpScript = `#!/bin/bash\necho "PHP 8.4.10 (cli)"\nif [[ "$1" == "-m" ]]; then\n  echo "pdo_sqlite"\n  echo "sqlite3"\nfi`
      fs.writeFileSync(phpBinary, mockPhpScript, { mode: 0o755 })

      const phpConfigBinary = path.join(mockInstallPath, 'bin', 'php-config')
      const mockPhpConfigScript = `#!/bin/bash\nif [[ "$1" == "--extension-dir" ]]; then\n  echo "${path.join(mockInstallPath, 'lib', 'php', '20240924')}"\nfi`
      fs.writeFileSync(phpConfigBinary, mockPhpConfigScript, { mode: 0o755 })

      // Test extension detection logic
      const extensionDir = path.join(mockInstallPath, 'lib', 'php', '20240924')
      const pgsqlExtension = path.join(extensionDir, 'pdo_pgsql.so')

      const hasExtension = fs.existsSync(pgsqlExtension)
      expect(hasExtension).toBe(false)
    })

    it('should detect existing PostgreSQL extension', async () => {
      // Create mock extension file
      const extensionDir = path.join(mockInstallPath, 'lib', 'php', '20240924')
      const pgsqlExtension = path.join(extensionDir, 'pdo_pgsql.so')

      fs.writeFileSync(pgsqlExtension, 'mock extension binary')

      const hasExtension = fs.existsSync(pgsqlExtension)
      expect(hasExtension).toBe(true)
    })

    it('should detect both PostgreSQL and MySQL extensions', async () => {
      const extensionDir = path.join(mockInstallPath, 'lib', 'php', '20240924')
      const pgsqlExtension = path.join(extensionDir, 'pdo_pgsql.so')
      const mysqlExtension = path.join(extensionDir, 'pdo_mysql.so')

      fs.writeFileSync(pgsqlExtension, 'mock pgsql extension')
      fs.writeFileSync(mysqlExtension, 'mock mysql extension')

      expect(fs.existsSync(pgsqlExtension)).toBe(true)
      expect(fs.existsSync(mysqlExtension)).toBe(true)
    })
  })

  describe('PHP Wrapper Script Creation', () => {
    it('should create PHP wrapper script with database extensions', async () => {
      // Create mock PHP binary
      const phpBinary = path.join(mockInstallPath, 'bin', 'php')
      fs.writeFileSync(phpBinary, '#!/bin/bash\necho "PHP 8.4.10"', { mode: 0o755 })

      // Create mock extensions
      const extensionDir = path.join(mockInstallPath, 'lib', 'php', '20240924')
      const pgsqlExtension = path.join(extensionDir, 'pdo_pgsql.so')
      const mysqlExtension = path.join(extensionDir, 'pdo_mysql.so')

      fs.writeFileSync(pgsqlExtension, 'mock pgsql extension')
      fs.writeFileSync(mysqlExtension, 'mock mysql extension')

      // Create wrapper script (simulating the function logic)
      const phpWrapperPath = path.join(mockInstallPath, 'bin', 'php-with-db')
      const extensions = [
        `-d extension=${pgsqlExtension}`,
        `-d extension=${mysqlExtension}`,
      ]

      const wrapperScript = `#!/bin/bash
# PHP wrapper with database extensions
# Generated by Launchpad
exec "${phpBinary}" ${extensions.join(' ')} "$@"
`

      fs.writeFileSync(phpWrapperPath, wrapperScript, { mode: 0o755 })

      // Verify wrapper script was created correctly
      expect(fs.existsSync(phpWrapperPath)).toBe(true)

      const wrapperContent = fs.readFileSync(phpWrapperPath, 'utf8')
      expect(wrapperContent).toContain('PHP wrapper with database extensions')
      expect(wrapperContent).toContain(`-d extension=${pgsqlExtension}`)
      expect(wrapperContent).toContain(`-d extension=${mysqlExtension}`)
      expect(wrapperContent).toContain(`exec "${phpBinary}"`)

      // Test that wrapper is executable
      const stats = fs.statSync(phpWrapperPath)
      expect(stats.mode & 0o111).toBeGreaterThan(0) // Has execute permissions
    })

    it('should create wrapper with only available extensions', async () => {
      const phpBinary = path.join(mockInstallPath, 'bin', 'php')
      fs.writeFileSync(phpBinary, '#!/bin/bash\necho "PHP 8.4.10"', { mode: 0o755 })

      // Create only PostgreSQL extension
      const extensionDir = path.join(mockInstallPath, 'lib', 'php', '20240924')
      const pgsqlExtension = path.join(extensionDir, 'pdo_pgsql.so')
      fs.writeFileSync(pgsqlExtension, 'mock pgsql extension')

      // Create wrapper with only available extensions
      const phpWrapperPath = path.join(mockInstallPath, 'bin', 'php-with-db')
      const extensions = [`-d extension=${pgsqlExtension}`]

      const wrapperScript = `#!/bin/bash
# PHP wrapper with database extensions
# Generated by Launchpad
exec "${phpBinary}" ${extensions.join(' ')} "$@"
`

      fs.writeFileSync(phpWrapperPath, wrapperScript, { mode: 0o755 })

      const wrapperContent = fs.readFileSync(phpWrapperPath, 'utf8')
      expect(wrapperContent).toContain(`-d extension=${pgsqlExtension}`)
      expect(wrapperContent).not.toContain('pdo_mysql.so')
    })

    it('should backup original PHP binary', async () => {
      const phpBinary = path.join(mockInstallPath, 'bin', 'php')
      const originalContent = '#!/bin/bash\necho "Original PHP"'
      fs.writeFileSync(phpBinary, originalContent, { mode: 0o755 })

      // Simulate backup process
      const originalPhpPath = `${phpBinary}.original`
      if (!fs.existsSync(originalPhpPath)) {
        fs.copyFileSync(phpBinary, originalPhpPath)
      }

      expect(fs.existsSync(originalPhpPath)).toBe(true)

      const backupContent = fs.readFileSync(originalPhpPath, 'utf8')
      expect(backupContent).toBe(originalContent)
    })
  })

  describe('PHP Configuration (php.ini) Creation', () => {
    it('should create php.ini with database extensions', async () => {
      const phpIniDir = path.join(mockInstallPath, 'etc')
      const phpIniPath = path.join(phpIniDir, 'php.ini')

      // Create mock extensions
      const extensionDir = path.join(mockInstallPath, 'lib', 'php', '20240924')
      const pgsqlExtension = path.join(extensionDir, 'pdo_pgsql.so')
      const mysqlExtension = path.join(extensionDir, 'pdo_mysql.so')

      fs.writeFileSync(pgsqlExtension, 'mock pgsql extension')
      fs.writeFileSync(mysqlExtension, 'mock mysql extension')

      // Create php.ini content
      const phpIniContent = `; PHP configuration with database extensions
; Generated by Launchpad

; Database Extensions
extension=${pgsqlExtension}
extension=${mysqlExtension}

; Core PHP Settings
date.timezone = "UTC"
memory_limit = 256M
upload_max_filesize = 64M
post_max_size = 64M

; Development settings
display_errors = On
error_reporting = E_ALL
log_errors = On
`

      fs.writeFileSync(phpIniPath, phpIniContent)

      expect(fs.existsSync(phpIniPath)).toBe(true)

      const iniContent = fs.readFileSync(phpIniPath, 'utf8')
      expect(iniContent).toContain(`extension=${pgsqlExtension}`)
      expect(iniContent).toContain(`extension=${mysqlExtension}`)
      expect(iniContent).toContain('date.timezone = "UTC"')
      expect(iniContent).toContain('memory_limit = 256M')
      expect(iniContent).toContain('display_errors = On')
    })

    it('should handle missing extension directory gracefully', async () => {
      const phpIniDir = path.join(mockInstallPath, 'etc')
      const phpIniPath = path.join(phpIniDir, 'php.ini')

      // Don't create extension files - test graceful handling
      const extensionDir = path.join(mockInstallPath, 'lib', 'php', '20240924')
      const pgsqlExtension = path.join(extensionDir, 'pdo_pgsql.so')
      const mysqlExtension = path.join(extensionDir, 'pdo_mysql.so')

      // Create basic php.ini without extensions
      const phpIniContent = `; PHP configuration with database extensions
; Generated by Launchpad

; Core PHP Settings
date.timezone = "UTC"
memory_limit = 256M

; Development settings
display_errors = On
error_reporting = E_ALL
`

      fs.writeFileSync(phpIniPath, phpIniContent)

      const iniContent = fs.readFileSync(phpIniPath, 'utf8')
      expect(iniContent).not.toContain(`extension=${pgsqlExtension}`)
      expect(iniContent).not.toContain(`extension=${mysqlExtension}`)
      expect(iniContent).toContain('date.timezone = "UTC"')
    })
  })

  describe('Database Service Integration', () => {
    it('should have correct PostgreSQL service definition', () => {
      // Test the PostgreSQL service definition structure
      const expectedPostgresConfig = {
        name: 'postgres',
        displayName: 'PostgreSQL',
        packageDomain: 'postgresql.org',
        executable: 'postgres',
        port: 5432,
        supportsGracefulShutdown: true,
      }

      // This tests that our service definition matches expected structure
      expect(expectedPostgresConfig.name).toBe('postgres')
      expect(expectedPostgresConfig.port).toBe(5432)
      expect(expectedPostgresConfig.supportsGracefulShutdown).toBe(true)
    })

    it('should have correct MySQL service definition', () => {
      const expectedMysqlConfig = {
        name: 'mysql',
        displayName: 'MySQL',
        packageDomain: 'mysql.com',
        executable: 'mysqld',
        port: 3306,
        supportsGracefulShutdown: true,
      }

      expect(expectedMysqlConfig.name).toBe('mysql')
      expect(expectedMysqlConfig.port).toBe(3306)
      expect(expectedMysqlConfig.supportsGracefulShutdown).toBe(true)
    })

    it('should validate PostgreSQL postStartCommands syntax', () => {
      // Test that our PostgreSQL postStartCommands have correct structure
      const postStartCommands = [
        ['createdb', '-h', '127.0.0.1', '-p', '5432', '-U', 'postgres', 'launchpad_dev'],
        ['psql', '-h', '127.0.0.1', '-p', '5432', '-U', 'postgres', '-d', 'postgres', '-c', 'CREATE USER IF NOT EXISTS laravel WITH PASSWORD \'launchpad123\';'],
        ['psql', '-h', '127.0.0.1', '-p', '5432', '-U', 'postgres', '-d', 'postgres', '-c', 'ALTER DATABASE launchpad_dev OWNER TO laravel;'],
      ]

      // Validate command structure
      postStartCommands.forEach((command) => {
        expect(Array.isArray(command)).toBe(true)
        expect(command.length).toBeGreaterThan(0)
        expect(typeof command[0]).toBe('string')
      })

      // Validate specific commands
      expect(postStartCommands[0][0]).toBe('createdb')
      expect(postStartCommands[1][0]).toBe('psql')
      expect(postStartCommands[1].join(' ')).toContain('CREATE USER IF NOT EXISTS laravel')
    })

    it('should validate MySQL postStartCommands syntax', () => {
      const postStartCommands = [
        ['mysql', '-u', 'root', '-e', 'CREATE DATABASE IF NOT EXISTS launchpad_dev;'],
        ['mysql', '-u', 'root', '-e', 'CREATE USER IF NOT EXISTS \'laravel\'@\'localhost\' IDENTIFIED BY \'launchpad123\';'],
        ['mysql', '-u', 'root', '-e', 'GRANT ALL PRIVILEGES ON launchpad_dev.* TO \'laravel\'@\'localhost\';'],
      ]

      postStartCommands.forEach((command) => {
        expect(Array.isArray(command)).toBe(true)
        expect(command.length).toBeGreaterThan(0)
        expect(typeof command[0]).toBe('string')
      })

      expect(postStartCommands[0][0]).toBe('mysql')
      expect(postStartCommands[0].join(' ')).toContain('CREATE DATABASE IF NOT EXISTS launchpad_dev')
    })
  })

  describe('PHP Extension Compilation Process', () => {
    it('should handle compilation errors gracefully', async () => {
      // Test error handling when compilation fails
      let compilationError: Error | null = null

      try {
        // Simulate a compilation error scenario
        const invalidSourceDir = path.join(tempDir, 'invalid-source')
        // const extensionDir = path.join(mockInstallPath, 'lib', 'php', '20240924')

        // This would normally cause an error in the compilation process
        if (!fs.existsSync(invalidSourceDir)) {
          throw new Error('Source directory not found')
        }
      }
      catch (error) {
        compilationError = error as Error
      }

      expect(compilationError).not.toBeNull()
      expect(compilationError?.message).toContain('Source directory not found')
    })

    it('should validate PHP version compatibility', () => {
      // Test that we're using a valid PHP version for extension compilation
      const phpVersion = '8.4.10'

      // Validate version format
      const versionPattern = /^\d+\.\d+\.\d+$/
      expect(versionPattern.test(phpVersion)).toBe(true)

      // Validate it's a supported version (8.3+)
      const [major, minor] = phpVersion.split('.').map(Number)
      expect(major).toBeGreaterThanOrEqual(8)
      if (major === 8) {
        expect(minor).toBeGreaterThanOrEqual(3)
      }
    })

    it('should validate extension compilation arguments', () => {
      // Test that compilation arguments are properly formatted
      const pgsqlArgs = ['--with-pdo-pgsql']
      const mysqlArgs = ['--with-pdo-mysql']

      expect(Array.isArray(pgsqlArgs)).toBe(true)
      expect(Array.isArray(mysqlArgs)).toBe(true)

      expect(pgsqlArgs[0]).toContain('--with-pdo-pgsql')
      expect(mysqlArgs[0]).toContain('--with-pdo-mysql')
    })

    it('should validate temporary directory cleanup', async () => {
      // Test that temporary compilation directories are properly cleaned up
      const tempCompileDir = path.join(tempDir, 'php-ext-compile')

      // Create temp directory
      fs.mkdirSync(tempCompileDir, { recursive: true })
      fs.writeFileSync(path.join(tempCompileDir, 'test-file.txt'), 'test content')

      expect(fs.existsSync(tempCompileDir)).toBe(true)

      // Simulate cleanup
      fs.rmSync(tempCompileDir, { recursive: true, force: true })

      expect(fs.existsSync(tempCompileDir)).toBe(false)
    })
  })

  describe('Integration with Existing PHP Installation', () => {
    it('should work with existing PHP installation', async () => {
      // Create a more realistic PHP installation structure
      const phpBinary = path.join(mockInstallPath, 'bin', 'php')
      const phpConfigBinary = path.join(mockInstallPath, 'bin', 'php-config')
      const phpizeBinary = path.join(mockInstallPath, 'bin', 'phpize')

      // Create mock binaries
      fs.writeFileSync(phpBinary, '#!/bin/bash\necho "PHP 8.4.10 (cli)"', { mode: 0o755 })
      fs.writeFileSync(phpConfigBinary, '#!/bin/bash\necho "Extension dir test"', { mode: 0o755 })
      fs.writeFileSync(phpizeBinary, '#!/bin/bash\necho "Configuring extension"', { mode: 0o755 })

      // Verify all required tools exist
      expect(fs.existsSync(phpBinary)).toBe(true)
      expect(fs.existsSync(phpConfigBinary)).toBe(true)
      expect(fs.existsSync(phpizeBinary)).toBe(true)

      // Verify they're executable
      const phpStats = fs.statSync(phpBinary)
      const phpConfigStats = fs.statSync(phpConfigBinary)
      const phpizeStats = fs.statSync(phpizeBinary)

      expect(phpStats.mode & 0o111).toBeGreaterThan(0)
      expect(phpConfigStats.mode & 0o111).toBeGreaterThan(0)
      expect(phpizeStats.mode & 0o111).toBeGreaterThan(0)
    })

    it('should handle missing PHP tools gracefully', async () => {
      // Test graceful handling when PHP tools are missing
      const phpBinary = path.join(mockInstallPath, 'bin', 'php')
      // Don't create php-config or phpize

      fs.writeFileSync(phpBinary, '#!/bin/bash\necho "PHP 8.4.10"', { mode: 0o755 })

      expect(fs.existsSync(phpBinary)).toBe(true)
      expect(fs.existsSync(path.join(mockInstallPath, 'bin', 'php-config'))).toBe(false)
      expect(fs.existsSync(path.join(mockInstallPath, 'bin', 'phpize'))).toBe(false)

      // This should trigger graceful fallback in the actual implementation
    })
  })

  describe('Extension Loading and Verification', () => {
    it('should create testable PHP extension loading', async () => {
      // Create a test script that verifies extensions are loaded
      const testScript = path.join(tempDir, 'test-extensions.php')
      const testContent = `<?php
$extensions = ['pdo_pgsql', 'pdo_mysql', 'pdo_sqlite'];
foreach ($extensions as $ext) {
  echo $ext . ': ' . (extension_loaded($ext) ? 'YES' : 'NO') . PHP_EOL;
}
?>`

      fs.writeFileSync(testScript, testContent)
      expect(fs.existsSync(testScript)).toBe(true)

      // Verify test script content
      const content = fs.readFileSync(testScript, 'utf8')
      expect(content).toContain('pdo_pgsql')
      expect(content).toContain('pdo_mysql')
      expect(content).toContain('extension_loaded')
    })

    it('should validate database connection capabilities', async () => {
      // Test that would validate database connections work
      const connectionTest = {
        postgresql: 'pgsql:host=localhost;port=5432;dbname=test',
        mysql: 'mysql:host=localhost;port=3306;dbname=test',
        sqlite: 'sqlite::memory:',
      }

      // Validate DSN formats
      expect(connectionTest.postgresql).toContain('pgsql:')
      expect(connectionTest.mysql).toContain('mysql:')
      expect(connectionTest.sqlite).toContain('sqlite:')

      expect(connectionTest.postgresql).toContain('port=5432')
      expect(connectionTest.mysql).toContain('port=3306')
    })
  })
})
